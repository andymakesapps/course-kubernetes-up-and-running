import os
import yaml
from pathlib import Path
from typing import Dict, Any, List

# --- Configuration ---
# The absolute path to your controllers directory.
# Modify this path to match your environment.
# For demonstration, it's set to a relative path.
CRD_ROOT_PATH = "./cluster/controllers/"
# The directory where the markdown files will be saved.
OUTPUT_DIR = "./crd_documentation"


# --- End Configuration ---


def generate_tree_view(properties: Dict[str, Any], indent_level: int = 0) -> List[str]:
    """
    Recursively generates a human-readable, YAML-like tree structure of the spec.

    Args:
        properties: The dictionary of properties from the CRD schema.
        indent_level: The current indentation level for formatting.

    Returns:
        A list of strings, where each string is a line in the tree view.
    """
    lines = []
    indent = ' ' * (indent_level * 2)

    for key, schema in properties.items():
        prop_type = schema.get('type')

        if prop_type == 'object':
            lines.append(f"{indent}{key}:")
            sub_properties = schema.get('properties', {})
            lines.extend(generate_tree_view(sub_properties, indent_level + 1))

        elif prop_type == 'array':
            lines.append(f"{indent}{key}:")
            item_schema = schema.get('items', {})
            item_type = item_schema.get('type')

            array_item_prefix = ' ' * (indent_level * 2) + ' - '

            if item_type == 'object':
                sub_properties = item_schema.get('properties', {})
                sub_lines = generate_tree_view(sub_properties, indent_level + 1)

                # Attach the first property to the array marker '-'
                if sub_lines:
                    first_line = sub_lines[0].lstrip()
                    lines.append(f"{array_item_prefix}{first_line}")
                    # Add subsequent properties with correct indentation
                    for line in sub_lines[1:]:
                        lines.append(' ' * (indent_level * 2 + 2) + line.lstrip())

            elif item_type == 'string':
                lines.append(f"{array_item_prefix}string")
            # Other primitive array types can be added here if needed.

        elif prop_type == 'string':
            lines.append(f"{indent}{key}: string")

        else:  # For other types like integer, boolean, just show the key.
            lines.append(f"{indent}{key}:")

    return lines


def generate_flat_table(
        properties: Dict[str, Any],
        required_list: List[str],
        parent_path: str = ''
) -> List[Dict[str, str]]:
    """
    Recursively flattens the spec properties into a list for table generation.

    Args:
        properties: The dictionary of properties from the CRD schema.
        required_list: A list of keys that are required at the current level.
        parent_path: The base path from the parent for nested fields.

    Returns:
        A list of dictionaries, where each dict represents a row in the table.
    """
    table_rows = []

    for key, schema in properties.items():
        current_path = f"{parent_path}{key}"
        prop_type = schema.get('type', 'N/A')
        description = schema.get('description', 'No description provided.').replace('\n', ' ')
        required = "Required" if key in required_list else "Optional"

        row = {
            'Field': f"`{current_path}`",
            'Type': f"`{prop_type}`",
            'Description': description,
            'Required': required
        }
        table_rows.append(row)

        if prop_type == 'object':
            sub_properties = schema.get('properties', {})
            sub_required = schema.get('required', [])
            table_rows.extend(generate_flat_table(sub_properties, sub_required, f"{current_path}."))

        elif prop_type == 'array':
            item_schema = schema.get('items', {})
            item_type = item_schema.get('type')
            # Add '[]' to path to indicate an array of items.
            array_path = f"{current_path}[]"

            if item_type == 'object':
                sub_properties = item_schema.get('properties', {})
                sub_required = item_schema.get('required', [])
                table_rows.extend(generate_flat_table(sub_properties, sub_required, f"{array_path}."))

    return table_rows


def process_crd_file(crd_path: Path):
    """
    Parses a single CRD file and generates markdown documentation.
    """
    print(f"Processing CRD: {crd_path.name}...")
    try:
        with open(crd_path, 'r') as f:
            crd = yaml.safe_load(f)
    except yaml.YAMLError as e:
        print(f"  -> ❌ Error parsing YAML: {e}")
        return
    except Exception as e:
        print(f"  -> ❌ Could not read file: {e}")
        return

    if not crd or 'spec' not in crd or 'versions' not in crd['spec']:
        print("  -> ⚠️ Skipping: Invalid or incomplete CRD structure.")
        return

    spec = crd.get('spec', {})
    group = spec.get('group')
    resource_plural = spec.get('names', {}).get('plural')

    if not group or not resource_plural:
        print("  -> ⚠️ Skipping: Missing group or plural name in CRD spec.")
        return

    for version_info in spec.get('versions', []):
        is_served = version_info.get('served', False)
        is_storage = version_info.get('storage', False)

        # Only document the version that is both served and used for storage
        if is_served and is_storage:
            try:
                schema = version_info['schema']['openAPIV3Schema']['properties']['spec']
                spec_properties = schema.get('properties', {})
                top_level_required = schema.get('required', [])
            except KeyError:
                print(f"  -> ⚠️ Skipping version {version_info.get('name')}: Schema path not found.")
                continue

            # 1. Generate the tree view
            tree_lines = generate_tree_view(spec_properties)
            tree_content = "\n".join(tree_lines)

            # 2. Generate the flat table
            table_rows_data = generate_flat_table(spec_properties, top_level_required)
            table_header = "| Field | Type | Description | Required |\n|---|---|---|---|"
            table_rows_md = [
                f"| {row['Field']} | {row['Type']} | {row['Description']} | {row['Required']} |"
                for row in table_rows_data
            ]
            table_content = "\n".join([table_header] + table_rows_md)

            # 3. Assemble the final Markdown file
            md_content = (
                f"# Spec for {crd.get('kind', 'Unknown Kind')}\n\n"
                f"**Group:** `{group}`\n\n"
                f"**Version:** `{version_info.get('name')}`\n\n"
                "This document outlines the fields available in the `.spec` of a "
                f"`{crd.get('kind', 'Unknown Kind')}` resource.\n\n"
                "--- \n\n"
                "## Spec Structure\n\n"
                "```yaml\n"
                f"{tree_content}\n"
                "```\n\n"
                "--- \n\n"
                "## Field Details\n\n"
                f"{table_content}\n"
            )

            # 4. Write to file
            output_filename = f"{group}_{resource_plural}.md"
            output_path = Path(OUTPUT_DIR) / output_filename
            output_path.parent.mkdir(parents=True, exist_ok=True)

            with open(output_path, 'w') as f:
                f.write(md_content)

            print(f"  -> ✅ Generated documentation at: {output_path}")
            # Stop after processing the first valid version
            break
    else:
        print("  -> ℹ️ No version found with served=true and storage=true.")


def main():
    """
    Main function to find and process all CRDs.
    """
    print("🚀 Starting CRD documentation generation...")
    root_path = Path(CRD_ROOT_PATH)

    if not root_path.is_dir():
        print(f"❌ Error: Root directory not found at '{root_path}'")
        print("Please update the 'CRD_ROOT_PATH' variable in the script.")
        return

    controller_dirs = [d for d in root_path.iterdir() if d.is_dir()]

    if not controller_dirs:
        print("No controller directories found.")
        return

    for controller_dir in controller_dirs:
        crd_bases_path = controller_dir / "config" / "crd" / "bases"

        if crd_bases_path.is_dir():
            print(f"\nChecking controller: {controller_dir.name}")
            crd_files = list(crd_bases_path.glob('*.yaml')) + list(crd_bases_path.glob('*.yml'))
            if not crd_files:
                print("  -> No CRD files found.")
                continue

            for crd_file in crd_files:
                process_crd_file(crd_file)
        else:
            print(f"\nSkipping controller '{controller_dir.name}': No 'config/crd/bases' directory found.")


if __name__ == "__main__":
    main()
    print("\n🎉 Documentation generation complete.")
